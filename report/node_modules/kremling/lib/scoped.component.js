'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Scoped = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.resetCounter = resetCounter;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var styleTags = {};
var counter = 0;

var reactSupportsReturningArrays = !!_reactDom2.default.createPortal;

var Scoped = exports.Scoped = function (_React$Component) {
  _inherits(Scoped, _React$Component);

  function Scoped(props) {
    _classCallCheck(this, Scoped);

    var _this = _possibleConstructorReturn(this, (Scoped.__proto__ || Object.getPrototypeOf(Scoped)).call(this, props));

    _initialiseProps.call(_this);

    _this.state = {};
    if (!props.css && !props.postcss) throw Error('Kremling\'s <Scoped /> component requires either the \'css\' or \'postcss\' props.');
    if (props.css && props.postcss) throw Error('Kremling\'s <Scoped /> component requires either the \'css\' or \'postcss\' props. Cannot use both.');
    if (props.postcss && !(typeof props.postcss.styles === 'string' && props.postcss.id)) throw Error('Kremlings\'s <Scoped /> component \'postcss\' prop requires an object containing \'styles\' and \'id\' properties. Try using the kremling-loader.');
    if (props.css) {
      _this.state = _this.newCssState(props);
    } else {
      _this.state = _this.newPostcssState(props);
    }
    return _this;
  }

  _createClass(Scoped, [{
    key: 'render',
    value: function render() {
      var kremlingChildren = this.addKremlingAttributeToChildren(this.props.children);

      if (reactSupportsReturningArrays) {
        return kremlingChildren;
      } else {
        // React 15 or below
        if (kremlingChildren.length > 1) {
          throw new Error('kremling\'s <Scoped /> component requires exactly one child element unless you are using react@>=16');
        } else if (kremlingChildren.length === 1) {
          return kremlingChildren[0];
        } else {
          return null;
        }
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      if (this.props.css) {
        if (this.state.css !== this.props.css) {
          this.doneWithCss();
          this.setState(this.newCssState(this.props));
        }
      } else {
        if (prevProps.postcss.id !== this.props.postcss.id || prevProps.postcss.styles !== this.props.postcss.styles || prevProps.postcss.namespace !== this.props.postcss.namespace) {
          this.doneWithPostcss();
          this.setState(this.newPostcssState(this.props));
        }
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (this.props.css) {
        this.doneWithCss();
      } else {
        this.doneWithPostcss();
      }
    }
  }, {
    key: 'newCssState',
    value: function newCssState(props) {
      if (typeof props.css !== 'string') {
        return;
      }

      if (props.css.indexOf("&") < 0 && props.css.trim().length > 0) {
        var firstRule = props.css.substring(0, props.css.indexOf("{")).trim();
        console.warn('Kremling\'s <Scoped css="..."> css prop should have the \'&\' character in it to scope the css classes: ' + firstRule);
      }

      var styleRef = void 0,
          kremlingAttrName = void 0,
          kremlingAttrValue = void 0;
      var existingDomEl = styleTags[props.css];

      if (existingDomEl) {
        styleRef = existingDomEl;
        existingDomEl.kremlings++;
        kremlingAttrName = styleRef.kremlingAttr;
        kremlingAttrValue = styleRef.kremlingValue;
      } else {
        // The attribute for namespacing the css
        kremlingAttrName = 'data-' + (props.namespace || Scoped.defaultNamespace);
        kremlingAttrValue = counter++;

        // The css to append to the dom
        var kremlingSelector = '[' + kremlingAttrName + '="' + kremlingAttrValue + '"]';
        var transformedCSS = props.css.replace(/& ([^{}])+{/g, function (match, cssRule) {
          return match.split(",") // multiple rules on the same line split by a comma
          .map(function (cssSplit) {
            cssSplit = cssSplit.trim();

            // ignore css rules that don't begin with '&'
            if (cssSplit.indexOf('&') === -1) return cssSplit.replace('{', '').trim();

            cssSplit = /[^&](.+)[^{]+/g.exec(cssSplit)[0].trim();

            var builtIn = false;
            if (!/^([.#]\w+)/.test(cssSplit)) {
              builtIn = true;
            }
            // if it's not a built-in selector, prepend the data attribute. Otherwise, append
            return !builtIn ? kremlingSelector + ' ' + cssSplit + ', ' + kremlingSelector + cssSplit : kremlingSelector + ' ' + cssSplit + ', ' + cssSplit + kremlingSelector;
          }).join(", ") + ' {';
        });

        // The dom element
        var el = document.createElement('style');
        el.setAttribute('type', 'text/css');
        el.textContent = transformedCSS;
        el.kremlings = 1;
        el.kremlingAttr = kremlingAttrName;
        el.kremlingValue = kremlingAttrValue;
        document.head.appendChild(el);
        styleTags[props.css] = el;
        styleRef = el;
      }

      return {
        css: props.css,
        styleRef: styleRef,
        kremlingAttrName: kremlingAttrName,
        kremlingAttrValue: kremlingAttrValue
      };
    }
  }]);

  return Scoped;
}(_react2.default.Component);

// For tests


Scoped.propTypes = {
  css: _propTypes2.default.string,
  postcss: _propTypes2.default.object,
  namespace: _propTypes2.default.string
};
Scoped.defaultNamespace = 'kremling';

var _initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this.addKremlingAttributeToChildren = function (children) {
    return _react2.default.Children.map(children, function (child) {
      if (_react2.default.isValidElement(child)) {
        if (child.type === _react2.default.Fragment && _react2.default.Fragment) {
          var fragmentChildren = _this2.addKremlingAttributeToChildren(child.props.children);
          return _react2.default.cloneElement(child, {}, fragmentChildren);
        } else {
          return _react2.default.cloneElement(child, _defineProperty({}, _this2.state.kremlingAttrName, _this2.state.kremlingAttrValue));
        }
      } else {
        return child;
      }
    });
  };

  this.doneWithCss = function () {
    if (_this2.state.styleRef && --_this2.state.styleRef.kremlings === 0) {
      _this2.state.styleRef.parentNode.removeChild(_this2.state.styleRef);
      delete styleTags[_this2.props.css];
    }
  };

  this.doneWithPostcss = function () {
    _this2.state.styleRef.counter -= 1;
    if (_this2.state.styleRef.counter === 0) {
      _this2.state.styleRef.parentNode.removeChild(_this2.state.styleRef);
    }
  };

  this.newPostcssState = function (props) {
    var kremlingAttrName = props.postcss.namespace || 'data-kremling';
    var kremlingAttrValue = props.postcss.id;
    var styleRef = _this2.state.styleRef || document.head.querySelector('[' + kremlingAttrName + '="' + kremlingAttrValue + '"]');
    if (!styleRef) {
      styleRef = document.createElement('style');
      styleRef.setAttribute('type', 'text/css');
      styleRef.counter = 1;
    } else {
      styleRef.counter += 1;
    }
    styleRef.setAttribute(kremlingAttrName, kremlingAttrValue);
    styleRef.innerHTML = props.postcss.styles;
    document.head.appendChild(styleRef);
    return {
      kremlingAttrName: kremlingAttrName,
      kremlingAttrValue: kremlingAttrValue,
      styleRef: styleRef
    };
  };
};

function resetCounter() {
  counter = 0;
}
//# sourceMappingURL=scoped.component.js.map